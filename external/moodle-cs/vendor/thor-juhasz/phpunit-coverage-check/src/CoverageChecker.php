<?php declare(strict_types=1);
/*
 * This file is part of phpunit-coverage-check.
 *
 * (c) Thor Juhasz <thor@juhasz.pro>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace PHPUnitCoverageCheck;

use Exception;
use InvalidArgumentException;
use OutOfRangeException;
use SimpleXMLElement;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use function bccomp;
use function bcdiv;
use function bcmul;
use function file_exists;
use function file_get_contents;
use function gettype;
use function in_array;
use function is_numeric;
use function is_string;
use function join;
use function sprintf;

class CoverageChecker extends Command
{
    private const METRIC_ELEMENTS = 'elements';

    private const METRIC_STATEMENTS = 'statements';

    private const METRIC_METHODS = 'methods';

    public static array $allowedMetrics = [
        self::METRIC_ELEMENTS,
        self::METRIC_STATEMENTS,
        self::METRIC_METHODS,
    ];

    /**
     * {@inheritDoc}
     */
    protected function configure(): void
    {
        $this->setName('phpunit-coverage-check')
            ->setDescription(
                <<<EOT
                A PHPUnit test coverage checker.

                  This command will parse a clover.xml report file (generated by PHPUnit),
                  to check that the test coverage meets a certain threshold (80% by default).
                EOT
            )
            ->addArgument(
                'file',
                InputArgument::REQUIRED,
                'Clover XML report file.'
            )
            ->addOption(
                'threshold',
                't',
                InputOption::VALUE_REQUIRED,
                'Coverage threshold. Must be a number ranging from 0 to 100.',
                '80'
            )
            ->addOption(
                'metric',
                'm',
                InputOption::VALUE_REQUIRED,
                'The metric to measure coverage from. Possible values are <comment>elements, statements & methods</comment>.',
                'elements'
            )
            ->addOption(
                'suppress-errors',
                's',
                InputOption::VALUE_NONE,
                'Set to true so command will not give a non-zero exit code when the test coverage is under the threshold.'
            );

    }

    /**
     * {@inheritDoc}
     *
     * @throws Exception
     */
    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        /** @var string|bool|int|float|null $file */
        $file = $input->getArgument('file');
        if ($file !== null) {
            $file = (string) $file;
        }

        /** @var string|bool|int|float|null $threshold */
        $threshold = $input->getOption('threshold');
        if ($threshold !== null) {
            $threshold = (string) $threshold;
        }

        /** @var string|bool|int|float|null $metric */
        $metric         = $input->getOption('metric');
        if ($metric !== null) {
            $metric = (string) $metric;
        }

        $suppressErrors = (bool) $input->getOption('suppress-errors');

        // Validate
        $this->validate($file, $threshold, $metric);

        /**
         * @var string                 $file
         * @var string                 $threshold
         * @var string                 $metric
         * @var string                 $suppressErrors
         *
         * @psalm-var static::METRIC_* $metric
         * @psalm-var numeric-string   $threshold
         */

        $xml = new SimpleXMLElement(file_get_contents($file));

        $coverage     = $this->coverageFromXml($xml, $metric);
        $isAcceptable = bccomp($coverage, $threshold, 2) !== -1;

        $this->message($coverage, $threshold, $isAcceptable, $output);

        return $isAcceptable || $suppressErrors ? 0 : 1;
    }

    /**
     * @param mixed $file
     * @param string|null $threshold
     * @param string|int|null $metric
     *
     * @throws InvalidArgumentException
     * @throws OutOfRangeException
     */
    private function validate($file, ?string $threshold, $metric): void
    {
        if (is_string($file) === false) {
            throw new InvalidArgumentException(
                'You must specify the name of the clover XML report file as an argument.'
            );
        }

        if (file_exists($file) === false) {
            $message = sprintf(
                'The clover XML report file could not be found (%s).',
                $file
            );
            throw new InvalidArgumentException($message);
        }

        $threshold = (string) $threshold;

        if (is_numeric($threshold) === false) {
            throw new InvalidArgumentException(
                'The test coverage threshold must be a number between 0 and 100 (inclusive).'
            );
        }

        if (
            bccomp($threshold, "0", 2) === -1 || bccomp($threshold, "100", 2) === 1
        ) {
            $message = sprintf(
                'The test coverage threshold should be a number between 0 and 100 (inclusive), %d given.',
                $threshold
            );
            throw new OutOfRangeException($message);
        }

        if (in_array($metric, static::$allowedMetrics) === false) {
            $message = sprintf(
                'The metric to be measured must be one of "%s". %s given.',
                join(", ", static::$allowedMetrics),
                $metric ?: 'null'
            );
            throw new InvalidARgumentException($message);
        }
    }

    /**
     * @param SimpleXMLElement $xml
     * @param string           $metric
     *
     * @return string
     *
     * @psalm-return numeric-string
     */
    private function coverageFromXml(SimpleXMLElement $xml, string $metric): string
    {
        $foundMetrics   = $xml->xpath('//metrics');
        $totalMetrics   = 0;
        $coveredMetrics = 0;

        foreach ($foundMetrics as $currentMetric) {
            $totalMetrics   += (int) $currentMetric[$metric];
            $coveredMetrics += (int) $currentMetric['covered' . $metric];
        }

        /** @psalm-var numeric-string $div */
        $div = bcdiv((string) $coveredMetrics, (string) $totalMetrics, 2);

        return bcmul($div, "100", 2);
    }

    /**
     * @param string               $coverage
     * @param string               $threshold
     * @param bool                 $isAcceptable
     * @param OutputInterface      $output
     *
     * @psalm-param numeric-string $coverage
     * @psalm-param numeric-string $threshold
     */
    private function message(string $coverage, string $threshold, bool $isAcceptable, OutputInterface $output): void
    {
        $coverageDisplay = sprintf("%.2f%%", $coverage);
        if ((float) $coverage === (float) sprintf("%d", $coverage)) {
            $coverageDisplay = sprintf("%d%%", $coverage);
        }

        $thresholdDisplay = sprintf("%.2f%%", $threshold);
        if ((float) $threshold === (float) sprintf("%d", $threshold)) {
            $thresholdDisplay = sprintf("%d%%", $threshold);
        }

        $fullCoverage = $thresholdDisplay === "100%";
        $suffix       = sprintf(
            '(requires %s)',
            $fullCoverage ? 'full coverage' : sprintf('>= %s coverage', $thresholdDisplay)
        );

        if ($isAcceptable === false) {
            $message = sprintf(
                '<error>[ERROR] Code coverage is %s, which is not acceptable %s</error>',
                $coverageDisplay,
                $suffix
            );

            $output->writeln($message);

            return;
        }

        $message = sprintf(
            '<info>[OK] Code coverage is %s, which is acceptable %s</info>',
            $coverageDisplay,
            $suffix
        );

        $output->writeln($message);
    }
}
